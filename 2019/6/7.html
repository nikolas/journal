<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Adjustable noise data based on a curve</title>
        <meta name="author" content="Nikolas Nyby">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link href="https://fonts.googleapis.com/css?family=Lora:400,700" rel="stylesheet" type="text/css">
        <link rel="stylesheet" href="../../journal.css" type="text/css" />
    </head>
    <body>

        <article itemscope itemtype="http://schema.org/BlogPosting">
            <header>
                <h1 itemprop="name">Adjustable noise data based on a curve</h1>
                <div style="display: none;" itemprop="author">Nikolas Nyby</div>
                <time datetime="2019-06-07" itemprop="datePublished">Friday, June 7, 2019</time>
            </header>



            <div itemprop="articleBody">
                <p>
                    I've been working on an 
                    <a href="https://ccnmtl.github.io/astro-simulations/exoplanet-transit-simulator/">Exoplanet Transit Simulator</a>,
                    and part of this simulation displays randomized
                    data, with an adjustable randomization factor,
                    connected to an arbitrary curve.  When you click
                    "Show simulated measurements", you can adjust the
                    noise level of data points connected to the
                    lightcurve. These data points are what an
                    astronomer sees when looking for clues of a planet
                    orbiting a distant star.
                </p>
                <p>
                    We start off with the theoretical lightcurve. This
                    generated by some complicated calculations in
                    <a href="https://github.com/ccnmtl/astro-simulations/blob/master/exoplanet-transit-simulator/src/Lightcurve.js">Lightcurve.js</a>.
                    It's just a 2-dimensional array representing x-y values
                    on the plot.
                </p>
                <p>
                    Here I'll go through the noise data function and
                    describe how it's put together.
                </p>
<pre>
/**   
 * Generate noise around the lightcurve.
 */
getNoiseData(lightcurveData) {
    if (!this.props.showSimulatedMeasurements) {
        return [];
    }
</pre>
                <p>
                    First, find the extent of the lightcurve data - these X values
                    go somewhere between 0 to 400.
                </p>
<pre>
    const xExtent = d3.extent(lightcurveData, d => d[0]);
</pre>
                <p>
                    <code>xExtent</code> is now [0, 400]. Now we'll make a bunch of 
                    random X values for this noise. The Y values are influenced by the actual
                    lightcurve, but the X values are just completely random.
                </p>
<pre>
    const randomizedData = [];
    for (let i = 0; i < this.props.simMeasurementNumber; i++) {
        const randX = Math.random() * xExtent[1];
</pre>
                <p>
                    Now I have a random X value for this noise
                    data. Great. But how do I define the Y value?  It
                    can't be completely random: it needs to be tied to
                    the lightcurve, with an adjustable randomness.
                    Well the first step is finding where the
                    lightcurve is at this random X value. That's not
                    so straightforward, because I don't have just a
                    mathematical formula for the curve that I can plug
                    <code>randX</code> into.
                </p>
                <p>
                    d3 has a family of &quot;bisector&quot; functions
                    that return the index in an array where a given x
                    value belongs, if it were to be inserted and
                    maintain sorted order. So that's what I'm using
                    here: this says, give me the index into
                    lightcurveData that randX belongs. I don't actually
                    modify lightcurveData, just use that index to find
                    the closest Y value.
                </p>
<pre>
        // Find the closest lightcurve point to this random x
        // value.
        const idx = d3.bisector(function (d) {
            return d[0];
        }).left(lightcurveData, randX);

        // Generate noise based on the real y val.
        const y = lightcurveData[idx][1];
<p>
    The rest is pretty straightforward: add some level of randomness
    to this Y value, depending on the adjustable noise value.
</p>
        const newY = y + (
            // Scale the randomization factor by the value
            // of the "noise" slider
            (Math.random() - 0.5) * this.props.noise);

        randomizedData.push([randX, newY]);
    }

    return randomizedData;
}
</pre>
<small>- <a href="https://github.com/ccnmtl/astro-simulations/blob/master/exoplanet-transit-simulator/src/LightcurveView.jsx#L19">LightcurveView.jsx</a>
            </div>

        </article>
        
        <footer>
            <a href="../../" title="Back">&larr;</a>
        </footer>
    </body>
</html>
